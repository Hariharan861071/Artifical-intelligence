from heapq import heappush, heappop

class Puzzle:
    def __init__(self, board, parent=None, move="", depth=0):
        self.board = board
        self.parent = parent
        self.move = move
        self.depth = depth
        self.cost = 0  # total cost = depth + heuristic

    def __lt__(self, other):
        return self.cost < other.cost

    def __eq__(self, other):
        return self.board == other.board

    def __hash__(self):
        return hash(str(self.board))

def manhattan_distance(board, goal):
    distance = 0
    for i in range(3):
        for j in range(3):
            if board[i][j] == 0:
                continue
            val = board[i][j]
            goal_x, goal_y = divmod(val - 1, 3)
            distance += abs(i - goal_x) + abs(j - goal_y)
    return distance

def get_neighbors(board):
    neighbors = []
    # Find zero position
    x, y = next((i, j) for i in range(3) for j in range(3) if board[i][j] == 0)
    directions = [("Up", (x-1, y)), ("Down", (x+1, y)), ("Left", (x, y-1)), ("Right", (x, y+1))]

    for move, (nx, ny) in directions:
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_board = [list(row) for row in board]
            # Swap zero with neighbor
            new_board[x][y], new_board[nx][ny] = new_board[nx][ny], new_board[x][y]
            neighbors.append((move, new_board))
    return neighbors

def reconstruct_path(node):
    path = []
    while node.parent:
        path.append(node.move)
        node = node.parent
    path.reverse()
    return path

def solve_puzzle(start_board):
    goal_board = [[1, 2, 3],
                  [4, 5, 6],
                  [7, 8, 0]]

    start_node = Puzzle(start_board)
    start_node.cost = manhattan_distance(start_board, goal_board)

    open_set = []
    heappush(open_set, start_node)
    closed_set = set()

    while open_set:
        current = heappop(open_set)

        if current.board == goal_board:
            return reconstruct_path(current)

        closed_set.add(current)

        for move, neighbor_board in get_neighbors(current.board):
            neighbor = Puzzle(neighbor_board, current, move, current.depth + 1)
            neighbor.cost = neighbor.depth + manhattan_distance(neighbor_board, goal_board)

            if neighbor in closed_set:
                continue

            # Add neighbor to open set if not visited or better cost
            heappush(open_set, neighbor)

    return None  # No solution found

if __name__ == "__main__":
    start = [
        [1, 2, 3],
        [4, 0, 6],
        [7, 5, 8]
    ]

    solution = solve_puzzle(start)

    if solution:
        print("Solution found in", len(solution), "moves:")
        print(solution)
    else:
        print("No solution found.")
